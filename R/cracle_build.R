#' @import raster
#' @import dismo
NULL

#' Extract environmental data
#' 
#' This function is a feature-added wrapper for raster::extract();
#' @param data Distribution data. A data.frame that should include (at least) a column for species/taxon name named 'tax', latitude named 'lat', longitude named 'lon', and an optional column 'sub' if it is necessary to define subgroups (i.e., if 'tax' corresponds to genera but sampling needs to know which records belong to which species. See param 'schema' below). 
#' @param clim A raster object (see raster::raster() and raster::stack() documentation for reading raster files into R).
#' @param schema A string of value "raw", "flat", or "species" to define the sampling protocol. In "raw", all records are counted (including duplicate exact localities). In "flat", all unique localities will be counted where a unique locality is defined as a raster grid cell. Under the "flat" sampling strategy two records in the same raster grid cell will be counted as one. The option "species", only applies when taxa are identified as genera and species identities are represented in the "sub" column of the data object. In "species", each unique locality is counted for each species within the group (taxon). This weighs more diverse localities higher. Default is "raw".
#' @param factor An integer value for the methods "flat" and "spec" to increase the systematic sampling grid size to courser resolutions than the given climate grid. The value of factor corresponds to the number of rows and columns to aggregate into each courser grid cell. Default is 0 which will not be processed.
#' @export
#' @examples
#' #distr <- read.table('test_mat.txt', head=T, sep ="\t");
#' #OR:
#' data(distr);
#' data(climondbioclim);
#' extr.raw = extraction(data=distr, clim= climondbioclim, schema='raw');
#' extr.flat = extraction(data=distr, clim= climondbioclim, schema='flat');
#' extr.spec = extraction(data=distr, clim= climondbioclim, schema='species');
extraction <- function(data, clim, schema = "raw", factor = 0){

	if(length(data[,1]) < 5){cat('ERR: Too few records\n'); return()}

	mat.larr <- data;
	phytoclim <- clim;
  #nclat <- which(colnames(mat.larr)=='lat');
	#nclon <- which(colnames(mat.larr)=='lon');
		
	extr.larr <- raster::extract(phytoclim, cbind(mat.larr$lon, mat.larr$lat), cellnumbers=T);
	extr.larr <- cbind(mat.larr, extr.larr);
	if(schema != 'raw'){
		if(factor == 0){} else {
			r2 <- aggregate(phytoclim, fact = factor, fun=mean);
			tmp.ext <- raster::extract(r2, cbind(mat.larr$lon, mat.larr$lat), cellnumbers=T);
			extr.larr[,(ncol(extr.larr)+1)] = extr.larr[,'cells'];
			extr.larr[,'cells'] = tmp.ext[,'cells'];
			
		}
		
		
	}
	extr.larr <- stats::na.omit(extr.larr)
	if(schema == "raw"){
		holder <- data.frame();
		tlist <- unique(extr.larr$tax);
		for(i in 1:length(tlist)){
			set <- subset(extr.larr, extr.larr$tax == tlist[i]);
		
			#if(length(set[,1])>=5){
				holder <- rbind(holder, set);
				print(length(holder[,1]))
				
			#}			
		}
		extr.larr = holder;
	} else {
		holder <- data.frame();
		tlist <- unique(extr.larr$tax);
		for(i in 1:length(tlist)){
			set <- subset(extr.larr, extr.larr$tax == tlist[i]);
			if(schema == "flat"){
				sub = set
				sub <- sub[!duplicated(sub[,"cells"]),];
				#if(length(sub[,1])>=5){
					holder <- rbind(holder, sub);
			#	}	
			}
			if(schema == "species"){
				glist <- unique(set$sub);
				for(n in 1:length(glist)){
					sub <- subset(set, set$sub == glist[n]);
					sub <- sub[!duplicated(sub[,"cells"]),];
					if(length(sub[,1])>=5){
						holder <- rbind(holder, sub);
					}
				}		
			}
		}
		extr.larr <- holder; 
	}
	if(schema != 'raw'){

		extr.larr[,'cells'] = extr.larr[,ncol(extr.larr)];

		extr.larr = extr.larr[,-ncol(extr.larr)];
	}
  print("EXTRACTION MONITOR:")
	#  print(length(holder[,1]));
	
	print(length(extr.larr[,1]));
  
  extr.larr[,1] = as.numeric(as.character(extr.larr[,1]))
	
	return(extr.larr);
};



#' Generate standard probability density functions for each taxon/variable
#' 
#' This function takes extracted climate data (from an object generated by the vegdistmod::extraction() function) for one taxon/species and generates probability density functions for variable using both a Gaussian (normal) approximation and a Gaussian Kernel Density estimator.
#' @param ex An object derived from the extraction() function.
#' @param clim A raster object (see raster::raster() and raster::stack() documentation for reading raster files into R).
#' @param name A character string describing (preferably) the group for which PDFs are being constructed (i.e., a species binomial). If none is supplied, a value of column "tax" is selected as a default.
#' @param bw A bandwidth compatible with stats::density(). Options include "nrd", "nrd0", "ucv", "bcv", etc.. Default (and recommended) value is "nrd0".
#' @param n Number of equally spaced points at which the probability density is to be estimated. Defaults to 1024. A lower number increases speed but decreases resolution in the function. A higher number increases resolution at the cost of speed. Recommended values: 512, 1024, 2048, ....
#' @param manip Character string of 'reg' for straight likelihood, 'condi' for conditional likelihood, or 'bayes' for a Bayesian style likelihood statement.
#' @export
#' @examples
#' #distr <- read.table('test_mat.txt', head=T, sep ="\t");
#' data(distr);
#' data(climondbioclim);
#' extr.raw = extraction(data=distr, clim= climondbioclim, schema='raw');
#' extr.sub = subset(extr.raw, extr.raw$tax == extr.raw[5,'tax']);
#' dens.sub = densform(extr.sub, clim = climondbioclim, bw = 'nrd0', n = 512);
#' densplot(dens.sub, names(climondbioclim[[1]]));

densform <- function(ex, clim, name = '', bw = "nrd0", manip = 'reg', n = 1024){
  condi = FALSE;
  bayes = FALSE;
  if(manip == 'condi') {
    condi = TRUE; #print("Conditional Likelihood")
  }
  if(manip == 'bayes'){
    bayes = TRUE; #print("Bayesian-ish Likelihood")
  }
	data = ex;
	if(name == ''){
		name = data[2,'tax'];
	};
	pi = 22/7;
	extr.larr <- data;
	head = which(colnames(ex) %in% 'cells') - 1;
	#print(head);
	#head = 5;
	phytoclim <- clim;
		larr.den <- data.frame();
 		larr.den.x <- data.frame();
		larr.den.gauss <- data.frame();
		larr.mean <- data.frame();
		larr.sd <- data.frame();
		eval <- data.frame();
		bg.eval = data.frame();
		if(condi == TRUE | bayes == TRUE){
  		bgn = 3000;
	  	bg <- dismo::randomPoints(clim, bgn);
	  	bgn = length(bg[,1]);
		  bg <- cbind(rep("0000", bgn), rep("bg", bgn), as.numeric(as.character(bg[,2])), as.numeric(as.character(bg[,1])));
  		bg <- data.frame(bg)
	  	bg[,3] = as.numeric(as.character(bg[,3]));
		  bg[,4] = as.numeric(as.character(bg[,4]));
  		colnames(bg) <- c("ind_id", "tax", "lat", "lon")
  		bg.ex <- extraction(bg, clim, schema='raw');
		}
		for(i in 1:length(names(phytoclim))){	
			from <- raster::minValue(phytoclim[[i]]);
			to <- raster::maxValue(phytoclim[[i]]);

			den <- stats::density(as.numeric(extr.larr[,names(phytoclim[[i]])]), n = n, from = from, to = to, bw = bw);
			if(condi == TRUE){
  			bg.den <- stats::density(as.numeric(bg.ex[,names(phytoclim[[i]])]), n = n, from = from, to = to, bw = bw); 
	  		bg.den$y <- bg.den$y + min(subset(bg.den$y, bg.den$y > 0));
		  	den$y <- (den$y/bg.den$y); ##Try also (dens$y/bg.dens$y)*dens$y ##Not sure what this represents but it tempers the effect of the background significantly
		  	bg.mean <- mean(bg.ex[,names(phytoclim[[i]])]);
		  	bg.sd <- sd(bg.ex[,names(phytoclim[[i]])]);
			}
			if(bayes == TRUE){
			  bg.den <- stats::density(as.numeric(bg.ex[,names(phytoclim[[i]])]), n = n, from = from, to = to, bw = bw); 
			  bg.den$y <- bg.den$y + min(subset(bg.den$y, bg.den$y > 0));
			  den$y <- (den$y/bg.den$y)*den$y;
			  bg.mean <- mean(bg.ex[,names(phytoclim[[i]])]);
			  bg.sd <- sd(bg.ex[,names(phytoclim[[i]])]);
			}
			
			
			mean <- mean(extr.larr[,names(phytoclim[[i]])]);
			sd <- sd(extr.larr[,i+head+1]);
			
			if(sd == 0 || is.na(sd) == "TRUE"){
				sd = 0.01;
			};
			for(num in 1:length(den$x)){
				eval[num,1] <- ((1/(sqrt(2*pi)*sd)*(2.71828^(-1*((den$x[num] - mean)^2)/(2*sd^2)))));
				if(condi==T | bayes==T){
          bg.eval[num,1] <- ((1/(sqrt(2*pi)*bg.sd)*(2.71828^(-1*((den$x[num] - bg.mean)^2)/(2*bg.sd^2)))));
				}
			};
			larr.den[1:n, i] <- den$y;
			larr.den.x[1:n, i] <- den$x;
			if(condi == T){
			  eval[,1] = (eval[,1]/bg.eval[,1]);
			}
			if(bayes == T){
			  eval[,1] = (eval[,1]/bg.eval[,1])*eval[,1];
			}
			larr.den.gauss[1:n, i] <- eval[,1];
			larr.mean[1,i] <- mean;
			larr.sd[1,i] <- sd;
		};
		colnames(larr.den.gauss) <- c(paste(names(phytoclim), "gauss", sep = "."));
		colnames(larr.mean) <- c(paste(names(phytoclim), "mean", sep = "."));
		colnames(larr.sd) <- c(paste(names(phytoclim), "sd", sep = "."));
		colnames(larr.den) <- c(paste(names(phytoclim), "kde", sep = "."));
		colnames(larr.den.x) <- c(paste(names(phytoclim), "x", sep = "."));
		name = data.frame(name);
		larr.mean = data.frame(larr.mean);
		larr.sd = data.frame(larr.sd);
		colnames(name) <- "name";
		fin <- c(larr.den, larr.den.x, larr.den.gauss, larr.mean, larr.sd, name);
		fin <- .makeaucone(fin);
		return(fin);
	
};

#' A wrapper for vegdistmod::densform where a multi-taxon extraction object can be passed to densform one taxon at a time.
#' 
#' This function takes extracted climate data (from an object generated by the vegdistmod::extraction() function) and generates probability density functions for each taxon/variable pair using both a Gaussian (normal) approximation and a Gaussian Kernel Density estimator.
#' @param ex An object derived from the extraction() function.
#' @param clim A raster object (see raster::raster() and raster::stack() documentation for reading raster files into R).
#' @param bw A bandwidth compatible with stats::density(). Options include "nrd", "nrd0", "ucv", "bcv", etc.. Default (and recommended) value is "nrd0".
#' @param n Number of equally spaced points at which the probability density is to be estimated. Defaults to 1024. A lower number increases speed but decreases resolution in the function. A higher number increases resolution at the cost of speed. Recommended values: 512, 1024, 2048, ....
#' @export
#' @examples
#' #distr <- read.table('test_mat.txt', head=T, sep ="\t");
#' #OR:
#' data(distr);
#' data(climondbioclim);
#' extr.raw = extraction(data=distr, clim= climondbioclim, schema='raw');
#' dens.list.raw <- dens_obj(extr.raw, clim = climondbioclim, bw = 'nrd0', n = 1024);
#' multiplot(dens.list.raw, names(climondbioclim[[1]]));

dens_obj <- function(ex, clim, manip = 'condi', bw = "nrd0", n = 1024) {
	rawbioclim = clim;
	ex <- data.frame(ex);
	
	
	dens.list <- list();
	nlist <- vector();
	site.ex <- "NOSITE";

	site.coord = 0;
	if(ex[1,2] == "SITECOORD"){	
		site.coord <- ex[1,];
		ex <- subset(ex, ex$tax != "SITECOORD");
		site.ex <- ex[1,];
		
	};
	tax.list <- unique(ex$tax);
	tax.list <- stats::na.omit(tax.list);

	trm.list <- vector();
	for(j in 1:length(tax.list)){
		if(length(subset(ex, ex$tax == tax.list[j])) >= 5){
			trm.list <- c(trm.list, as.character(tax.list[j]))
		} else {
		}
	}

	tax.list <- trm.list;
	
	for(i in 1:length(tax.list)){	
	
		s.ex <- subset(ex, ex$tax == tax.list[[i]]);
		
		s.ex <- stats::na.omit(s.ex);
		
		nlist[[i]] <- length(s.ex[,1])

		dens.list[[i]] <- (densform(s.ex, rawbioclim, name = tax.list[[i]], manip = manip, bw = bw, n=n));

	 	len <- length(dens.list[[i]]);
		if(len <= 1) {
			dens.list[[i]] <- NULL;
		};
	};
	return(dens.list);
}


#' P(A | B) = P(A) + P(B)
#' 
#' Using an object from the vegdistmod::dens_obj() function. Create a single density object (i.e., like that produced by vegdistmod::densform()) where the probability curves correspond to the probability density function of any one taxon/species from the original set occurring. This is not actually used in the implementation of finding the maximum joint likelihood in a CRACLE analysis, but is a good companion to the vegdistmod::and_fun() function.
#' @param dens.oblist An object derived from the vegdistmod::dens_ob() function.
#' @export
#' @examples
#' #distr <- read.table('test_mat.txt', head=T, sep ="\t");

#' #OR:
#' data(distr);
#' data(climondbioclim);
#' extr.raw = extraction(data=distr, clim= climondbioclim, schema='raw');
#' dens.list.raw <- dens_obj(extr.raw, clim = climondbioclim, bw = 'nrd0', n = 1024);
#' multiplot(dens.list.raw, names(climondbioclim[[1]]));
#' or <- or_fun(dens.list.raw);
#' addplot(or, names(climondbioclim[[1]]), col ='black');

or_fun <- function(dens.oblist){
	varlist <- names(dens.oblist[[1]]);
	varlist <- (varlist[1:((length(varlist)-1)/5)]);
	varlist <- sub(".kde", "", varlist);

	field <- list();
	gfield <- list();
	xfield <- list();
	meanadjust <- list();
	variances <- list();
	name = "ADDITION";
	for (n in 1:length(varlist)){
		var = varlist[n];
		varx <- paste(var, "x", sep = ".");
		vargauss <- paste(var, "gauss", sep = ".");
		varkde <- paste(var, "kde", sep = ".");

		varmean <- paste(var, "mean", sep = ".");
		varsd <- paste(var, "sd", sep = ".");
		meanlist <- list();
		sdlist <- list();
		dens.obcurr <- dens.oblist[[1]];
		to <- max(dens.obcurr[[varx]]);
		from <- min(dens.obcurr[[varx]]);
		num = length(dens.obcurr[[varx]]);
		by = (to - from)/num;
		meanlist[[1]] <- as.numeric(dens.obcurr[[varmean]]);
		sdlist[[1]] <- as.numeric(dens.obcurr[[varsd]])^2;
		prod <- as.numeric(dens.obcurr[[varkde]]);
		prod.gauss <- as.numeric(dens.obcurr[[vargauss]]);

		for(i in 2:length(dens.oblist)){
			dens.obnow <- dens.oblist[[i]];
			prod <- prod + (as.numeric(dens.obnow[[varkde]]));
			prod.gauss <- prod.gauss + (as.numeric(dens.obnow[[vargauss]]));
			prod.area <- sum(prod)*by;
			prod <- prod / prod.area;
			prod.gauss.area <- sum(prod.gauss)*by;
			prod.gauss <- prod.gauss / prod.gauss.area;
			meanlist[[i]] <- as.numeric(dens.obnow[[varmean]]);
			sdlist[[i]] <- as.numeric(dens.obnow[[varsd]])^2;
		};
		prod.area <- sum(prod)*by;
		prod <- prod / prod.area;
		prod.gauss.area <- sum(prod.gauss)*by;
		prod.gauss <- prod.gauss / prod.gauss.area;
		field[[n]] <- prod;
		gfield[[n]] <- prod.gauss;
		xfield[[n]] <- dens.obcurr[[varx]];
		meanadjust[[n]] <- as.numeric(meanlist)/as.numeric(sdlist);
		variances[[n]] <- 1/as.numeric(sdlist);
	};
	meansum <- lapply(meanadjust, sum);
	varisum <- lapply(variances, sum);
	wmeans <- mapply("/", meansum, varisum);
	wsd <- mapply("/", 1, varisum);
	wsd <- lapply(wsd, sqrt);
	field <- data.frame(field);
	gfield <- data.frame(gfield);
	xfield <- data.frame(xfield);
	colnames(field) <- (paste(varlist, "kde", sep = "."));
	colnames(gfield) <- paste(varlist, "gauss", sep = ".");
	names(wmeans) <- paste(varlist, "mean", sep = ".");
	names(wsd) <- paste(varlist, "sd", sep = ".");
	colnames(xfield) <- (paste(varlist, "x", sep = "."));
	name = data.frame(name);
	colnames(name) <- "name";
	fin <- c(field, xfield, gfield, wmeans, wsd, name);
	fin <- .makeaucone(fin);
	return(fin);
};

#' P(A | B) = P(A) * P(B)
#' 
#' Using an object from the vegdistmod::dens_obj() function. Create a single density object (i.e., like that produced by vegdistmod::densform()) where the probability curves correspond to the probability density function of ALL taxa/species from the original set occurring. 
#' @param dens.oblist An object derived from the vegdistmod::dens_ob() function.
#' @export
#' @examples
#' #distr <- read.table('test_mat.txt', head=T, sep ="\t");
#' #OR:
#' data(distr);
#' data(climondbioclim);
#' extr.raw = extraction(data=distr, clim= climondbioclim, schema='raw');
#' dens.list.raw <- dens_obj(extr.raw, clim = climondbioclim, bw = 'nrd0', n = 1024);
#' multiplot(dens.list.raw, names(climondbioclim[[1]]));
#' or <- or_fun(dens.list.raw);
#' addplot(or, names(climondbioclim[[1]]), col ='black');
#' and <- and_fun(dens.list.raw);
#' addplot(and, names(climondbioclim[[1]]), col ='black');

and_fun <- function(dens.oblist){
	dens.oblist <- .scramble(dens.oblist);
	varlist <- names(dens.oblist[[1]]); #print(varlist)
	varlist <- (varlist[1:((length(varlist)-1)/5)]) ;
	varlist <- sub(".kde", "", varlist);

	field <- list();
	gfield <- list();
	xfield <- list();
	meanadjust <- list();
	variances <- list();
	name = "PRODUCT";
	for (n in 1:length(varlist)){ #print(varlist[n])
		var = varlist[n]; 
		varx <- paste(var, "x", sep = ".");
		varkde <- paste(var, "kde", sep = ".");

		vargauss <- paste(var, "gauss", sep = ".");
		varmean <- paste(var, "mean", sep = ".");
		varsd <- paste(var, "sd", sep = ".");
		meanlist <- list();
		sdlist <- list();
		dens.obcurr <- dens.oblist[[1]];
		to <- max(dens.obcurr[[varx]]);
		from <- min(dens.obcurr[[varx]]);
		num = length(dens.obcurr[[varx]]);
		by = (to - from)/num;
		meanlist[[1]] <- as.numeric(dens.obcurr[[varmean]]);
		sdlist[[1]] <- as.numeric(dens.obcurr[[varsd]])^2;
		prod <- as.numeric(dens.obcurr[[varkde]]);
		prod <- prod*by;
		prod.gauss <- as.numeric(dens.obcurr[[vargauss]])*by;
		for(i in 2:length(dens.oblist)){dens.obnow <- dens.oblist[[i]];
			prod <- prod * (as.numeric(dens.obnow[[varkde]])*by);
			prod.area <- sum(prod)*by;
			prod <- prod / prod.area;
			prod.gauss <- prod.gauss * (as.numeric(dens.obnow[[vargauss]])*by);
			prod.gauss.area <- sum(prod.gauss)*by;
			prod.gauss <- prod.gauss / prod.gauss.area;
			meanlist[[i]] <- as.numeric(dens.obnow[[varmean]]);
			sdlist[[i]] <- as.numeric(dens.obnow[[varsd]])^2;
		};
		prod.area <- sum(prod)*by;
		prod <- prod / prod.area;
		prod.gauss.area <- sum(prod.gauss)*by;
		prod.gauss <- prod.gauss / prod.gauss.area;
		field[[n]] <- prod;
		gfield[[n]] <- prod.gauss;
		xfield[[n]] <- dens.obcurr[[varx]];
		meanadjust[[n]] <- as.numeric(meanlist)/as.numeric(sdlist);
		variances[[n]] <- 1/as.numeric(sdlist);
	};
	meansum <- lapply(meanadjust, sum);
	varisum <- lapply(variances, sum);
	wmeans <- mapply("/", meansum, varisum);
	wsd <- mapply("/", 1, varisum);
	wsd <- lapply(wsd, sqrt);
	field <- data.frame(field);
	gfield <- data.frame(gfield);
	xfield <- data.frame(xfield);
	colnames(field) <- paste(varlist, "kde", sep = ".");
	colnames(gfield) <- paste(varlist, "gauss", sep = ".");
	names(wmeans) <- paste(varlist, "mean", sep = ".");
	names(wsd) <- paste(varlist, "sd", sep = ".");
	colnames(xfield) <- (paste(varlist, "x", sep = "."));
	name = data.frame(name);
	colnames(name) <- "name";
	fin <- c(field, xfield, gfield, wmeans, wsd, name);
	fin <- .makeaucone(fin);
	return(fin);
};

#get_optim() takes an object output from the densform function or and_fun or or_fun and finds optimal values for each PDF
#' Find PDF optim(a)um
#' 
#' Using an object from the vegdistmod::dens_obj() function. Create a single density object (i.e., like that produced by vegdistmod::densform()) where the probability curves correspond to the probability density function of ALL taxa/species from the original set occurring. 
#' @param dens.ob An object derived from the vegdistmod::dens_ob() function.
#' @export
#' @examples
#' #distr <- read.table('test_mat.txt', head=T, sep ="\t");
#' #OR:
#' data(distr);
#' data(climondbioclim);
#' extr.raw = extraction(data=distr, clim= climondbioclim, schema='raw');
#' dens.list.raw <- dens_obj(extr.raw, clim = climondbioclim, bw = 'nrd0', n = 1024);
#' multiplot(dens.list.raw, names(climondbioclim[[1]]));
#' and <- and_fun(dens.list.raw);
#' addplot(and, names(climondbioclim[[1]]), col ='black');
#' optim.and <- get_optim(and);
#' abline(v=optim.and$means[paste(names(climondbioclim[[1]]), 'mean', sep = ".") ])

get_optim <- function(dens.ob){
	dens.ob1 <- dens.ob;
	varlist <- names(dens.ob1);
	varlist <- (varlist[1:((length(varlist)-1)/5)]);
	varlist <- sub(".kde", "", varlist);
	conintkde <- list();
	conintgauss <- list();
	dirconint <- list();
	origk <- list();
	origg <- list();
	means <- list();
	sds <- list();
	for (j in 1:length(varlist)){
		var = varlist[[j]];
		varx <- paste(var, "x", sep = ".");
		#print(varx)
		vargauss <- paste(var, "gauss", sep = ".");
		varkde <- paste(var, "kde", sep = ".");

		varmean <- paste(var, "mean", sep = ".");
		varsd <- paste(var, "sd", sep = ".");
		cumulkde <- list();
		cumulgauss <- list();
		cikde <- list();
		cigauss <- list();
		runkde <- 0;
		rungauss <- 0;
		to <- max(dens.ob1[[varx]]);
		from <- min(dens.ob1[[varx]]);
		num = length(dens.ob1[[varx]]);
		by = (to - from)/num;
		for (i in 1:length(dens.ob1[[varkde]])){
			runkde = runkde + (dens.ob1[[varkde]][i]*by);
			cumulkde[[i]] <- runkde;
			if(i==1){ 
				if(cumulkde[[i]] >= 0.025){
					cikde[[1]] <- dens.ob1[[varx]][i];
				};
				if(cumulkde[[i]] >= 0.975){
					cikde[[1]] <- dens.ob1[[varx]][i];
					cikde[[2]] <- dens.ob1[[varx]][i];
				};
			} else {
				if(cumulkde[[i-1]] < 0.025 && cumulkde[[i]] >= 0.025){
					cikde[[1]] <- dens.ob1[[varx]][i];
				};
			if(cumulkde[[i-1]] < 0.975 && cumulkde[[i]] >= 0.975){
				cikde[[2]] <- dens.ob1[[varx]][i];
			};
		};
		rungauss = rungauss + (dens.ob1[[vargauss]][i]*by);
		cumulgauss[[i]] <- rungauss;
		if(i==1){ 
			if(cumulgauss[[i]] >= 0.025){
				cigauss[[1]] <- dens.ob1[[varx]][i];
			};
			if(cumulgauss[[i]] >= 0.975){
				cigauss[[1]] <- dens.ob1[[varx]][i];
				cigauss[[2]] <- dens.ob1[[varx]][i];
			};
		} else {
			if(cumulgauss[[i-1]] < 0.025 && cumulgauss[[i]] >= 0.025){
				cigauss[[1]] <- dens.ob1[[varx]][i];
			};
			if(cumulgauss[[i-1]] < 0.975 && cumulgauss[[i]] >= 0.975){
				cigauss[[2]] <- dens.ob1[[varx]][i];
			};
		};
	};
	logkde <- ifelse(dens.ob1[[varkde]]>0, log(dens.ob1[[varkde]]*by), -Inf);
	origkde <- subset(dens.ob1[[varx]], logkde >= max(logkde)*1.01);
	origk[[j]] <- c(min(origkde), max(origkde));
	loggauss <- ifelse(dens.ob1[[vargauss]]>0, log(dens.ob1[[vargauss]]*by), -Inf);
	origgauss <- subset(dens.ob1[[varx]], loggauss >= max(loggauss)*1.01);
	origg[[j]] <- c(min(origgauss), max(origgauss));
	conintkde[[j]] <- c(cikde[[1]], cikde[[2]]);
	conintgauss[[j]] <- c(cigauss[[1]], cigauss[[2]]);
	dirconint[[j]] <- c((dens.ob1[[varmean]] - 1.96*dens.ob1[[varsd]]), (dens.ob1[[varmean]]+1.96*dens.ob1[[varsd]]));
	means[[j]] <- dens.ob1[[varmean]];
	sds[[j]] <- dens.ob1[[varsd]];
	};
	conintkde <- data.frame(conintkde);
	conintgauss <- data.frame(conintgauss);
	origk <- data.frame(origk);
	origg <- data.frame(origg);
	dirconint <- data.frame(dirconint);
	means <- data.frame(means);
	sds <- data.frame(sds);
	colnames(conintkde) <- paste(varlist, "cikde", sep = ".");
	colnames(conintgauss) <- paste(varlist, "cigauss", sep = ".");
	colnames(origk) <- paste(varlist, "origkde", sep = ".");
	colnames(origg) <- paste(varlist, "origgauss", sep = ".");
	colnames(dirconint) <- paste(varlist, "cidir", sep = ".");
	colnames(means) <- paste(varlist, "mean", sep = ".");
	colnames(sds) <- paste(varlist, "sd", sep = ".");
	ret <- list(conintkde, conintgauss, origk, origg, dirconint, means, sds);
	names(ret) <- c("conintkde", "conintgauss", "origk", "origg", "dirconint", "means", "sds");
	return(ret);
};



#makes area under any PDF curve equal 1 (good for standardizing curves to be compared). HIDDEN!
.makeaucone <- function(dens.ob1, var){ var <- names(dens.ob1);
	var <- (var[1:((length(var)-1)/5)]);
	var <- sub('.kde', '', var)
	for(i in 1:length(var)){
		varnow <- var[[i]];
		varx <- paste(var[[i]], "x", sep = ".");
		gauss <- paste(var[[i]], "gauss", sep = ".");
		kde <- paste(var[[i]], "kde", sep = ".");

		to <- max(dens.ob1[[varx]]);
		from <- min(dens.ob1[[varx]]);
		num <- length(dens.ob1[[varx]]);
		by = (to - from)/num;
		do <- sum(dens.ob1[[kde]])*by;
		do.gauss <- sum(dens.ob1[[gauss]])*by;
		dens.ob1[[kde]] <- dens.ob1[[kde]]/do;
		dens.ob1[[gauss]] <- dens.ob1[[gauss]]/do.gauss;
	};
	return(dens.ob1);
};

#scramble() reorders pdfs. No real reason to do this as order does not matter for the operations being done here.
.scramble <- function(x, k=3) {
	x.s <- seq_along(x);
	y.s <- sample(x.s);
	idx <- unlist(split(y.s, (match(y.s, x.s)-1) %/% k), use.names = FALSE);
	x[idx];
};


#' Plot PDF curve of given type and variable for single density object.
#' 
#' Using an object from the densform() function. Plot a single PDF curve in a new plot window.
#' @param dens.ob An object derived from the vegdistmod::dens_ob() function.
#' @param var A character string that matches one of the layer names in the source raster object.
#' @param col A color declaration. Default is a random color.
#' @param type A character string of value either ".kde" for a Kernel Density Estimator curve, or ".gauss" for a Gaussian (normal) curve. All other values will result in errors.
#' @export
#' @examples
#' #distr <- read.table('test_mat.txt', head=T, sep ="\t");
#' #OR:
#' data(distr); data(climondbioclim);
#' extr.raw = extraction(data=distr, clim= climondbioclim, schema='raw');
#' extr.sub = subset(extr.raw, extr.raw$tax == extr.raw[5,'tax']);
#' dens.sub = densform(extr.sub, clim = climondbioclim, bw = 'nrd0', n = 512);
#' densplot(dens.sub, names(climondbioclim[[1]]));

densplot <- function(dens.ob, var, col = sample(grDevices::colours()), type = ".kde") {
	
	varx <- paste(var, "x", sep = ".");
	graphics::par(mar= c(5,4,4,4) + 0.3);
	tempvarlist <- c("bio1", "bio2", "bio3", "bio4", "bio5", "bio6", "bio7", "bio8", "bio9", "bio10", "bio11", "MAT", "MaximumT", "MinimumT");
	if(var %in% tempvarlist){by = 10}else{by = 1};
	var <- paste(var, type, sep = "");
	graphics::plot(dens.ob[[varx]]/by, dens.ob[[var]], xlab = "", ylab = "", ylim = c(0, 4*max(dens.ob[[var]])), type = "l", lwd = 3, col = col, frame.plot=F, axes = F);
	graphics::axis(side = 2, at = pretty(c(0, 4*max(dens.ob[[var]]))));
	graphics::axis(side = 1, at = pretty(range(dens.ob[[varx]]/by)));
	graphics::mtext(var, side = 1, line =3);
	graphics::mtext("Kernel Density Estimation", side = 2, line = 3);
};



#' Plot PDF curves of given type and variable for density list object
#' 
#' Using an object from the vegdistmod::dens_obj() function. Plot a series PDF curves in a new plot window.
#' @param dens.oblist An object derived from the vegdistmod::dens_obj() function.
#' @param var A character string that matches one of the layer names in the source raster object.
#' @param col A color vector of the same length as the dens.oblist object. Default is 'grDevices::heat.colors(length(dens.oblist))'.
#' @param type A character string of value either ".kde" for a Kernel Density Estimator curve, or ".gauss" for a Gaussian (normal) curve. All other values will result in errors.
#' @export
#' @examples
#' #distr <- read.table('test_mat.txt', head=T, sep ="\t");
#' #OR:
#' data(distr); data(climondbioclim);
#' extr.raw = extraction(data=distr, clim= climondbioclim, schema='raw');
#' dens.list.raw <- dens_obj(extr.raw, clim = climondbioclim, bw = 'nrd0', n = 1024);
#' multiplot(dens.list.raw, names(climondbioclim[[1]]));

multiplot <- function(dens.oblist, var, col = grDevices::heat.colors(length(dens.oblist)), type = ".kde"){ 
	arr.dens.ob = dens.oblist;
	varx <- paste(var, "x", sep = ".");
	vart = paste(var, type, sep = '');

	current <- arr.dens.ob[[1]];
	densplot(current, var, col[1], type = type);
	max.x.hold = list(max(current[[varx]]));
	max.y.hold = list(max(current[[vart]]));
	names.hold = as.character(current[["name"]]);
	for(i in 2:length(arr.dens.ob)){
		current <- arr.dens.ob[[i]];
		addplot(current, var, col[i], type = type);
#		max.x.hold = c(max.x.hold, max(current[[varx]]));
#		max.y.hold = c(max.y.hold, max(current[[vart]]));
		names.hold = c(names.hold, as.character(current[["name"]]));
	};
#	max.x <- mean(as.numeric(as.character(max.x.hold)));
#	max.y <- mean(as.numeric(as.character(max.y.hold)));
	graphics::legend("topleft", legend = as.character(names.hold), lty=1, lwd=2, cex=0.8, col = col, box.col=NA);
};

#' Adds a single PDF plot to already open plot
#' 
#' Using an object from the vegdistmod::densform() or vegdistmod::and_fun() or vegdistmod::or_fun() functions, add a PDF over the existing plot. Useful for visualizing joint likelihood curves.
#' @param dens.ob An object derived from the vegdistmod::densform() or vegdistmod::and_fun() or vegdistmod::or_fun() functions.
#' @param var A character string that matches one of the layer names in the source raster object.
#' @param col A color declaration. Default is a random color.
#' @param type A character string of value either ".kde" for a Kernel Density Estimator curve, or ".gauss" for a Gaussian (normal) curve. All other values will result in errors.
#' @export
#' @examples
#' #distr <- read.table('test_mat.txt', head=T, sep ="\t");
#' #OR:
#' data(distr); data(climondbioclim);
#' #extr.raw = extraction(data=distr, clim= climondbioclim, schema='raw');
#' #dens.list.raw <- dens_obj(extr.raw, clim = climondbioclim, bw = 'nrd0', n = 1024);
#' #multiplot(dens.list.raw, names(climondbioclim[[1]]));
#' #or <- or_fun(dens.list.raw);
#' #addplot(or, names(climondbioclim[[1]]), col ='black');
#' #and <- and_fun(dens.list.raw);
#' #addplot(and, names(climondbioclim[[1]]), col ='black');

addplot <- function(dens.ob, var, col = sample(grDevices::colours()), type = ".kde") {
	varx <- paste(var, "x", sep = ".");
	tempvarlist <- c("bio1", "bio2", "bio3", "bio4", "bio5", "bio6", "bio7", "bio8", "bio9", "bio10", "bio11", "MAT", "MaximumT", "MinimumT");
	if(var %in% tempvarlist){by = 10}else{by = 1};
	var <- paste(var, type, sep = "");
	graphics::points(dens.ob[[varx]]/by, dens.ob[[var]], type = "l", lwd = 3, col = col);
};


#' Vegetation resampling CRACLE bootstrap.
#' 
#' Using an density list object (vegdistmod::dens_obj()) draw incomplete samples of taxa from the list of taxa and run CRACLE. The Gaussian and KDE derived maximum likelihood values are kept and summarized as confidence intervals and bootstrap mean and standard deviation for each variable. 
#' @param dens.oblist A density list object derived from the vegdistmod::dens_obj() function.
#' @param clim A raster file containing environmental data. MUST be the same one used to create the density list object.
#' @param n Number of bootstrap iterations. Default is 100. 
#' @export
#' @examples
#' #distr <- read.table('test_mat.txt', head=T, sep ="\t");
#' #OR:
#' data(distr); data(climondbioclim);
#' extr.raw = extraction(data=distr, clim= climondbioclim, schema='raw');
#' dens.list.raw <- dens_obj(extr.raw, clim = climondbioclim, bw = 'nrd0', n = 1024);
#' and <- and_fun(dens.list.raw);
#' optima <- get_optim(and);
#' boot.raw <- cracboot(dens.list.raw, clim = climondbioclim, n = 100); 
#' #Compare to optima.
#' write_results(optima, clim = climondbioclim, method = 'conintkde', file = 'raw')
#' write_results(boot.raw, clim = climondbioclim, method = 'conintkde', file = 'boot.raw')



cracboot <- function(dens.oblist, clim, n = 100){
	dens.list <- dens.oblist;
	#if(length(dens.list)< 8){
	#	print("Too few taxa in sample for bootstrap");
	#	return(0);
	#}
	if(n < 50){
		print("ERR: Number of Iterations must be greater than 50");
		return(NULL);
	}

	nvars <- raster::nlayers(clim);
	varlist <- names(clim);
	val = list();

	nlist = vector();
	for (z in 1:length(dens.list)){
		nlist[[z]] = as.character(dens.list[[z]]$name);
	}

	for(i in 1:n){
		prop = stats::runif(1, 0.5, 0.9);
		size <- as.integer(prop*length(nlist))
		if(size < 2){
			size = 2;
		}
		sample <- sample(1:length(nlist), size, replace=F);
		data.sam <- nlist[sample];

		dens.sample <- list();
		now = 1;
		for(q in 1:length(dens.list)){
			if(dens.list[[q]]$name %in% data.sam) {
				dens.sample[[now]] = dens.list[[q]];
				now = now+1;
			} else {}
		}
		
		anded.sub <- and_fun(dens.sample)
		opti.sub <- get_optim(anded.sub)

		val[[i]] = opti.sub;
	}

		df.origk = matrix(ncol = nvars);
		df.origg = matrix(ncol = nvars);
		df.sds = matrix(ncol = nvars);
		df.means = matrix(ncol = nvars);
		for (x in 1:length(val)){
			origk = rbind(apply(val[[x]]$origk,2,mean));
			df.origk=rbind(df.origk, origk);
			df.origk = stats::na.omit(df.origk);
			origg = rbind(apply(val[[x]]$origg,2,mean));
			df.origg=rbind(df.origg, origg);
			df.origg = stats::na.omit(df.origg);

			sds = rbind(apply(val[[x]]$sds,2,mean));
			df.sds=rbind(df.sds, sds);
			df.sds = stats::na.omit(df.sds);
			means = rbind(apply(val[[x]]$means,2,mean));
			df.means=rbind(df.means, means);
			df.means = stats::na.omit(df.means);

		}

		##Reconstruct get_optim object from the stacks above
		conintkde <- list();
		conintgauss <- list();
		means <- list();
		sds <- list();
		for(j in 1:nvars){
			cikde <- sort(df.origk[,j]); 
			conintkde[[j]] <- c(cikde[[0.025*n]], cikde[[0.975*n]]);
			cigauss <- sort(df.origg[,j]); 
			conintgauss[[j]] <- c(cigauss[[0.025*n]], cigauss[[0.975*n]]);
			cimeans <- sort(df.means[,j]);		
			means[[j]] <- c(cimeans[[0.025*n]], cimeans[[0.975*n]]);
			cisds <- sort(df.sds[,j]);
			sds[[j]] <- c(cisds[[0.025*n]], cisds[[0.975*n]]);
		}	
		conintkde <- data.frame(conintkde);
		conintgauss <- data.frame(conintgauss);
		means <- data.frame(means);
		sds <- data.frame(sds);
		colnames(conintkde) <- paste(varlist, "cikde", sep = ".");
		colnames(conintgauss) <- paste(varlist, "cigauss", sep = ".");
		colnames(means) <- paste(varlist, "mean", sep = ".");
		colnames(sds) <- paste(varlist, "sd", sep = ".");
		ret <- list(conintkde, conintgauss, means, sds);
		names(ret) <- c("conintkde", "conintgauss", "means", "sds");
		return(ret);
		

}


#' Write results to file
#' 
#' Write results from a results object from either vegdistmod::get_optim() or vegdistmod::cracboot() to a tab delimited table in a text file. This is done one 'method' at a time. Supported methods are "conintkde", "conintgauss", "origg", "origk", "dirconint" for the "get_optim()" type objects and "conintkde" and "conintgauss" for the "cracboot()" type objects.
#' @param optima A results object from vegdistmod::get_optim() or vegdistmod::cracboot().
#' @param siteval A vector of site values for envirnomental parameters (See example for generating).
#' @param clim The original raster object used in the vegdistmod::extraction() step.
#' @param method The result summary method. Supported methods are "conintkde", "conintgauss", "origg", "origk", "dirconint" for the "get_optim()" type objects and "conintkde" and "conintgauss" for the "cracboot()" type objects.
#' @param filename Path to desired file.
#' @param append Should this be appended to an existing file. Default is FALSE.
#' @export
#' @examples
#' #distr <- read.table('test_mat.txt', head=T, sep ="\t");
#' #OR:
#' data(distr); data(climondbioclim);
#' extr.raw = extraction(data=distr, clim= climondbioclim, schema='raw');
#' dens.list.raw <- dens_obj(extr.raw, clim = climondbioclim, bw = 'nrd0', n = 1024);
#' and <- and_fun(dens.list.raw);
#' optima <- get_optim(and);
#' boot.raw <- cracboot(dens.list.raw, clim = climondbioclim, n = 100); 
#' #Compare to optima.
#' write_results(optima, clim = climondbioclim, method = 'conintkde', file = 'raw')
#' write_results(boot.raw, clim = climondbioclim, method = 'conintkde', file = 'boot.raw')

write_results <- function(optima, siteval = '', clim, method, filename, append = F){
	# type and file name writes output either
	# header including: site-coord, ntax, taxlist (if type = "hdr")
	#or a table of results if type = 'res'
	# site values, and results and comparison to site value.
	
			
		nvars <- raster::nlayers(clim);
		comp = matrix(nrow = nvars, ncol = 6);
		for(i in 1:nvars){		
			comp[i,2] = as.matrix(siteval[i+6]);
			comp[i,3] = optima[[method]][[i]][1];
			comp[i,4] = optima[[method]][[i]][2];
			comp[i,5] = as.numeric(comp[i,3])-as.numeric(comp[i,2]);
			comp[i,6] = as.numeric(comp[i,4])-as.numeric(comp[i,2]);
		};
		comp[,1] = names(clim);

		colnames(comp) = c("climate_variable", "site_value", paste(method, "min", sep = "_"), paste(method, "max", sep = "_"), "min_resid", "max_resid");
		file = paste(filename, method, 'tab', sep =".")
		utils::write.table(comp, file=file, append=append, sep="\t", quote=F, row.names=F, col.names=T);

}



#' Write a companion results file providing site details and final taxon list.
#' 
#' Companion file will include the environmental data extracted for the site locality, site locality information (lat/lon), and the list of taxa used in this analysis as derived from an extraction object. This list may differ from the original list requested if some taxa were excluded due to too few records left once filtered.
#' @param site.coord A vector of the site coordinates and any other desired site metadata.
#' @param tax.list A list of unique taxon names. Usually obtained by running 'tax.list <- unique(extraction_object$tax)' on your 'extraction_object' (See example).
#' @param filename The path to desired file.
#' @export
#' @examples
#' #distr <- read.table('test_mat.txt', head=T, sep ="\t");
#' #OR:
#' data(distr); data(climondbioclim);
#' extr.raw = extraction(data=distr, clim= climondbioclim, schema='raw');
#' site.coord <- extr.raw[1,1:5]; 
#' #Assuming that the site details are given in the first row of the original datafile. 
#' tax.list <- unique(subset(extr.raw, extr.raw$tax != 'SITECOORD')$tax); 
#' 
#' #Assumes that the site details are given in the original 
#' #data file and that the entry in the 'tax' column for the site is "SITECOORD". 
#' #Substitute whatever you called your site if you did it this way. OR:
#' #tax.list <- unique(extr.raw$tax);
#' write_headfile(site.coord=site.coord, tax.list=tax.list, filename = "headfile.try.hdr")


write_headfile <- function(site.coord = '', tax.list = '', filename){
			
			file = paste(filename, 'hdr', 'txt', sep = ".")
			utils::write.table("sitecoord", file=file, append=F, sep="\t", quote=F, col.names = F,  row.names=F);
			utils::write.table(site.coord, file=file, append=T, sep="\t", quote=F, col.names = F, row.names=F);
			utils::write.table("TaxNum", file=file, append =T, sep = "\t", quote=F, col.names = F, row.names=F);
			utils::write.table(length(tax.list), file=file, append =T, sep = "\t", quote=F, col.names = F,  row.names=F);
			utils::write.table("TaxList", file=file, append =T, sep = "\t", quote=F, col.names = F, row.names=F);
			utils::write.table(tax.list, file=file, append =T, sep = "\t", quote=F, col.names = F, row.names=F);
	
}


